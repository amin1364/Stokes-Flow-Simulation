%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Stokes-Flow-Simulation by Brendan Huang
% Script: generateBC_BEM_3D
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% MIT License
% 
% Copyright (c) 2015 Brendan K. Huang
% 
% Permission is hereby granted, free of charge, to any person obtaining a copy
% of this software and associated documentation files (the "Software"), to deal
% in the Software without restriction, including without limitation the rights
% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
% copies of the Software, and to permit persons to whom the Software is
% furnished to do so, subject to the following conditions:
% 
% The above copyright notice and this permission notice shall be included in all
% copies or substantial portions of the Software.
% 
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
% SOFTWARE.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Description: This function generates the boundary points and boundary
% conditions for the cavity driven fluid flow. There are several options
% for input
% 
% Inputs: 
% BCType - type of boundary conditions, either traction or velocity
% boundundbound - set as bound or unbound. The unbound (open) geometry consists
% of only a single horizontal surface, with fluid free to circulate
% elsewhere. The bound (closed) geometry is a rectangular cavity
% corner1, corner2 - these two points need to be 3D coordinates that give
% the bottom front left and top back right boundary of the cuboid cavity. In the
% case of the unbound condition, they will also define  the limits where
% we compute our flow
% nbc - number of boundary elements along each of the six walls of the
% surface (total points will be nbc x 6 for closed geometry)
% Ubound - set the speed (or traction) of the moving portion of the boundary
% fos - fraction of surface of bottom wall that is moving or applying
% traction to the fluid. fos = 1 means the entire wall moves
%
% Outputs:
% vertpts - location of vertices of triangles of boundary elements
% elemvert - vector to identify which vertices belong to which boundary element
% p - location of points where boundary elements are evaluated;
% bcx, bcy, bcz, bcu, bcv, bcw - values of boundary element points, both location and value of either velocity or traction; 
% alpha - index specifying at each of bcu, bcv, bcw whether it is a velocity or traction condition
% normv - normal vector of each boundary element

function [elemvert,vertpts,bcx,bcy,bcz,bcu,bcv,bcw,p,normv,alpha] = generateBC_BEM_3D(BCtype,boundunbound,corner1,corner2,nbc,Ubound,fos)

nx=nbc;
ny=nbc;
nz=nbc;

nxbot=nx;
nybot=ny;

switch boundunbound
    case 'bounded'
% This function custom generates a mesh of triangles on 6 surfaces. The
% mesh is generated by first creating a rectangular grid, then dividing
% each rectangle on the grid into right triangles with grd2tri and trigrid_com_norm. 
% For computational convenience here, each rectangle that is bisected gets cut
% into an A and B triangle, so we end up with two sets of triangles. This
% distinction is important because the ordering of the points on the
% triangle determines the direction of the normal vector. It also
% eventually determines the direction of integration for analytic integrals
% computed on the triangle.
[xtop,ytop] = meshgrid(linspace(corner1(1),corner2(1),nx),linspace(corner1(2),corner2(2),ny));
ztop=ones(size(xtop))*corner2(3);
[tritopA,tritopB]=grid2tri(ny,nx); %call grid2tri function to create two sets of triangles
[yright,zright] = meshgrid(linspace(corner1(2),corner2(2),ny),linspace(corner1(3),corner2(3),nz));
xright=ones(size(yright))*corner2(1);
[trirightA,trirightB]=grid2tri(nz,ny);
[yleft,zleft] = meshgrid(linspace(corner1(2),corner2(2),ny),linspace(corner1(3),corner2(3),nz));
xleft=ones(size(yleft))*corner1(1);
[trileftA,trileftB]=grid2tri(nz,ny,2);
[xback,zback] = meshgrid(linspace(corner1(1),corner2(1),nx),linspace(corner1(3),corner2(3),nz));
yback=ones(size(xback))*corner1(2);
[tribackA,tribackB]=grid2tri(nz,nx);
[xfront,zfront] = meshgrid(linspace(corner1(1),corner2(1),nx),linspace(corner1(3),corner2(3),nz));
yfront=ones(size(xfront))*corner2(2);
[trifrontA,trifrontB]=grid2tri(nz,nx,2);
[xbot,ybot] = meshgrid(linspace(corner1(1),corner2(1),nxbot),linspace(corner1(2),corner2(2),nybot));
zbot=ones(size(xbot))*corner1(3);
[tribotA,tribotB]=grid2tri(nybot,nxbot,2);

% trigrid_com_norm calculates the normal vector and center of mass of each
% of the triangles. The output of grid2tri contains indices but not
% absolute coordinates, so triggrid_com_norm incorporates the actual mesh
% location
[normbackA,combackA]=trigrid_com_norm(tribackA,xback,yback,zback);
[normbackB,combackB]=trigrid_com_norm(tribackB,xback,yback,zback);
[normfrontA,comfrontA]=trigrid_com_norm(trifrontA,xfront,yfront,zfront);
[normfrontB,comfrontB]=trigrid_com_norm(trifrontB,xfront,yfront,zfront);
[normtopA,comtopA]=trigrid_com_norm(tritopA,xtop,ytop,ztop);
[normtopB,comtopB]=trigrid_com_norm(tritopB,xtop,ytop,ztop);
[normbotA,combotA]=trigrid_com_norm(tribotA,xbot,ybot,zbot);
[normbotB,combotB]=trigrid_com_norm(tribotB,xbot,ybot,zbot);
[normleftA,comleftA]=trigrid_com_norm(trileftA,xleft,yleft,zleft);
[normleftB,comleftB]=trigrid_com_norm(trileftB,xleft,yleft,zleft);
[normrightA,comrightA]=trigrid_com_norm(trirightA,xright,yright,zright);
[normrightB,comrightB]=trigrid_com_norm(trirightB,xright,yright,zright);

% generate boundary conditions
bctop=zeros(size(xtop,1)-1,size(xtop,2)-1,3);
bcleft=zeros(size(xleft,1)-1,size(xleft,2)-1,3);
bcright=zeros(size(xright,1)-1,size(xright,2)-1,3);
bcfront=zeros(size(xfront,1)-1,size(xfront,2)-1,3);
bcback=zeros(size(xback,1)-1,size(xback,2)-1,3);

velboundleft=max(round((nxbot)*(1/2-fos/2)),1);
velboundright=min(round((nxbot)*(1/2+fos/2)),size(xbot,2)-1);
velboundback=max(round((nybot)*(1/2-fos/2)),1);
velboundfront=min(round((nybot)*(1/2+fos/2)),size(xbot,1)-1);


movingwallx=(velboundleft:velboundright);
movingwally=(velboundback:velboundfront);
bcbot=zeros(size(xbot,1)-1,size(xbot,2)-1,3);
bcbot(movingwally,movingwallx,1)=Ubound;

% We have to re order everything. By convention, we always do bottom,
% top, left, right, back, front
bctot_ordered=[reshape(bcbot(:,:,1),[],1),reshape(bcbot(:,:,2),[],1),reshape(bcbot(:,:,3),[],1); ...
         reshape(bcbot(:,:,1),[],1),reshape(bcbot(:,:,2),[],1),reshape(bcbot(:,:,3),[],1); ... 
         reshape(bctop(:,:,1),[],1),reshape(bctop(:,:,2),[],1),reshape(bctop(:,:,3),[],1); ... 
         reshape(bctop(:,:,1),[],1),reshape(bctop(:,:,2),[],1),reshape(bctop(:,:,3),[],1); ... 
         reshape(bcleft(:,:,1),[],1),reshape(bcleft(:,:,2),[],1),reshape(bcleft(:,:,3),[],1); ... 
         reshape(bcleft(:,:,1),[],1),reshape(bcleft(:,:,2),[],1),reshape(bcleft(:,:,3),[],1); ... 
         reshape(bcright(:,:,1),[],1),reshape(bcright(:,:,2),[],1),reshape(bcright(:,:,3),[],1); ... 
         reshape(bcright(:,:,1),[],1),reshape(bcright(:,:,2),[],1),reshape(bcright(:,:,3),[],1); ... 
         reshape(bcback(:,:,1),[],1),reshape(bcback(:,:,2),[],1),reshape(bcback(:,:,3),[],1); ... 
         reshape(bcback(:,:,1),[],1),reshape(bcback(:,:,2),[],1),reshape(bcback(:,:,3),[],1); ... 
         reshape(bcfront(:,:,1),[],1),reshape(bcfront(:,:,2),[],1),reshape(bcfront(:,:,3),[],1); ... 
         reshape(bcfront(:,:,1),[],1),reshape(bcfront(:,:,2),[],1),reshape(bcfront(:,:,3),[],1); ... 
         ];

bcu=bctot_ordered(:,1);
bcv=bctot_ordered(:,2);
bcw=bctot_ordered(:,3);

%Give a unique ordering to our vertex points
vertpts=[xbot(:),ybot(:),zbot(:);xtop(:),ytop(:),ztop(:);...
                xleft(:),yleft(:),zleft(:);xright(:),yright(:),zright(:);...
                xback(:),yback(:),zback(:);xfront(:),yfront(:),zfront(:)];
nptbot=nxbot*nybot;
npttop=nx*ny;
nptleft=ny*nz;
nptback=nx*nz;
shift1=nptbot;
shift2=shift1+npttop;
shift3=shift2+nptleft;
shift4=shift3+nptleft;
shift5=shift4+nptback;

% Index our triangles, now putting back together A and B 
elemvert=[tribotA;tribotB;tritopA+shift1;tritopB+shift1;...
          trileftA+shift2;trileftB+shift2;trirightA+shift3;trirightB+shift3;...
          tribackA+shift4;tribackB+shift4;trifrontA+shift5;trifrontB+shift5];
p=[combotA;combotB;comtopA;comtopB;...
          comleftA;comleftB;comrightA;comrightB;...
          combackA;combackB;comfrontA;comfrontB];
bcx=p(:,1);
bcy=p(:,2);
bcz=p(:,3);

normv=[normbotA;normbotB;normtopA;normtopB;...
          normleftA;normleftB;normrightA;normrightB;...
          normbackA;normbackB;normfrontA;normfrontB];

   case 'unbounded'
% This function custom generates a mesh of triangles on only the bottom surface.
% The mesh is generated by first creating a rectangular grid, then dividing
% each rectangle on the grid into right triangles with grd2tri. For
% computational convenience here, each rectangle that is bisected gets cut
% into an A and B triangle, so we end up with two sets of triangles. This
% distinction is important because the ordering of the points on the
% triangle determines the direction of the normal vector. It also
% eventually determines the direction of integration for analytic integrals
% computed on the triangle.

       
[xbot,ybot] = meshgrid(linspace(corner1(1),corner2(1),nxbot),linspace(corner1(2),corner2(2),nybot));
zbot=ones(size(xbot))*corner1(3);
[tribotA,tribotB]=grid2tri(nybot,nxbot,2);

% trigrid_com_norm calculates the normal vector and center of mass of each
% of the triangles.
[normbotA,combotA]=trigrid_com_norm(tribotA,xbot,ybot,zbot);
[normbotB,combotB]=trigrid_com_norm(tribotB,xbot,ybot,zbot);
velboundleft=max(round((nxbot-1)*(1/2-fos/2)),1);
velboundright=min(round((nxbot-1)*(1/2+fos/2)),size(xbot,2)-1);
velboundback=max(round((nybot-1)*(1/2-fos/2)),1);
velboundfront=min(round((nybot-1)*(1/2+fos/2)),size(xbot,1)-1);
movingwallx=(velboundleft:velboundright);
movingwally=(velboundback:velboundfront);
bcbot=zeros(size(xbot,1)-1,size(xbot,2)-1,3);
bcbot(movingwally,movingwallx,1)=Ubound;

% Re-order our boundary conditions
bctot_ordered=[reshape(bcbot(:,:,1),[],1),reshape(bcbot(:,:,2),[],1),reshape(bcbot(:,:,3),[],1); ...
               reshape(bcbot(:,:,1),[],1),reshape(bcbot(:,:,2),[],1),reshape(bcbot(:,:,3),[],1)]; 
bcu=bctot_ordered(:,1);
bcv=bctot_ordered(:,2);
bcw=bctot_ordered(:,3);

%Give a unique ordering to our vertex points
vertpts=[xbot(:),ybot(:),zbot(:)];
elemvert=[tribotA;tribotB];
p=[combotA;combotB];
bcx=p(:,1);
bcy=p(:,2);
bcz=p(:,3);
normv=[normbotA;normbotB];

end

% now we calculate alpha, which assigns a value to each boundary element 
% stating whether that element specifies a velocity or traction boundary
% condition. Notably, we may specify the z-direction as flow (impenetrable
% wall), but specify the x and y-direction as traction

switch BCtype
    case 'velocity'
        alpha=false(size(bctot_ordered));
        alpha=[alpha(:,1);alpha(:,2);alpha(:,3)];
    case 'traction'
        alpha=false(size(bctot_ordered));
        alpha(bctot_ordered~=0)=true;
        alpha=[alpha(:,1);alpha(:,2);alpha(:,3)];
end

end